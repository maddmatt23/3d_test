<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Directional Scroll Sequence (2_00000 → 2_00100)</title>
  <style>
    :root { --bg:#000; --hud:rgba(20,20,24,.55); --fg:#e8e8ee; }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);}
    /* Fullscreen canvas like Apple product pages */
    canvas{position:fixed; inset:0; width:100vw; height:100vh; background:#000;}
    .hud{position:fixed; left:12px; bottom:12px; padding:8px 10px; border-radius:10px; backdrop-filter: blur(6px); background:var(--hud); font:12px ui-monospace,Menlo,Consolas,monospace}
    .bar{height:4px; background:rgba(255,255,255,.12); border-radius:999px; overflow:hidden; margin-top:6px}
    .bar>span{display:block; height:100%; width:0%; background:linear-gradient(90deg,#7dd3fc,#60a5fa)}
    .help{position:fixed; right:12px; bottom:12px; font:12px/1.2 system-ui, sans-serif; opacity:.7}
  </style>
</head>
<body>
  <canvas id="cv"></canvas>
  <div class="hud" id="hud">
    frame <span id="fnum">2_00000</span>
    <div class="bar"><span id="prog"></span></div>
  </div>
  <div class="help">Scroll to scrub • Shift+←/→ = ±10 • Tap+drag to scrub</div>

<script>
// ===== CONFIG =====
const CONFIG = {
  basePath: './frames/',  // folder containing frames
  prefix: '2_',           // filename prefix
  start: 0,               // 0 → makes 2_00000 the first frame
  end: 100,               // inclusive → last is 2_00100
  pad: 5,                 // zero padding after underscore
  ext: 'png',             // your files are .png
  wheelSensitivity: 0.02, // higher = faster scrub (frames per wheel notch ~ deltaY/100)
  touchSensitivity: 0.15, // frames per 100px vertical swipe
  preloadRadius: 8        // how many neighbours to preload
};
// ===================

const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');
const hudNum = document.getElementById('fnum');
const progEl = document.getElementById('prog');

let W=0,H=0, DPR = Math.min(devicePixelRatio||1,2);
function resize(){
  W = canvas.clientWidth|0; H = canvas.clientHeight|0;
  canvas.width = Math.round(W*DPR); canvas.height = Math.round(H*DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  drawFrame(Math.round(frameF));
}
window.addEventListener('resize',resize);

// Sequence state
const total = CONFIG.end - CONFIG.start + 1;
let frameF = 0;            // floating-frame index for smooth scrubbing
let currentIndex = -1;     // last drawn integer index
const cache = new Map();   // index -> HTMLImageElement

function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function idxToName(i){ const n=(CONFIG.start+i).toString().padStart(CONFIG.pad,'0'); return `${CONFIG.prefix}${n}.${CONFIG.ext}`; }
function urlFor(i){ return `${CONFIG.basePath}${idxToName(i)}`; }

function load(i){
  if(cache.has(i)) return cache.get(i);
  const img = new Image();
  img.decoding='async'; img.loading='eager';
  img.src = urlFor(i);
  cache.set(i,img);
  return img;
}

function fitContain(img,w,h){
  const iw=img.naturalWidth||w, ih=img.naturalHeight||h;
  const s = Math.min(w/iw, h/ih);
  const dw=iw*s, dh=ih*s, dx=(w-dw)/2, dy=(h-dh)/2;
  ctx.clearRect(0,0,w,h);
  ctx.drawImage(img, dx, dy, dw, dh);
}

function drawFrame(i){
  i = clamp(i,0,total-1);
  if(i===currentIndex) return;
  currentIndex = i;
  const img = load(i);
  if(img.complete && img.naturalWidth>0){
    fitContain(img, W, H);
  } else {
    img.onload = ()=>{ if(i===currentIndex) fitContain(img, W, H); };
  }
  hudNum.textContent = idxToName(i);
  progEl.style.width = (i/(total-1))*100 + '%';
  // Preload neighbours
  for(let d=1; d<=CONFIG.preloadRadius; d++){
    const a=i-d, b=i+d; if(a>=0) load(a); if(b<=total-1) load(b);
  }
}

// Directional scrubbing (like Apple): we integrate scroll delta → frame index
let raf=null;
function scheduleDraw(){ if(raf) cancelAnimationFrame(raf); raf = requestAnimationFrame(()=> drawFrame(Math.round(frameF))); }

// Wheel / trackpad
window.addEventListener('wheel', (e)=>{
  // Prevent page from actually scrolling so the sequence "owns" the gesture
  e.preventDefault();
  // deltaY down is positive → advance; up is negative → reverse
  const step = (e.deltaY/100) * CONFIG.wheelSensitivity * (total-1);
  frameF = clamp(frameF + step, 0, total-1);
  scheduleDraw();
}, {passive:false});

// Keyboard
window.addEventListener('keydown', (e)=>{
  let d=0;
  if(e.key==='ArrowRight' || e.key==='ArrowDown') d = e.shiftKey? 10:1;
  if(e.key==='ArrowLeft'  || e.key==='ArrowUp')   d = -(e.shiftKey?10:1);
  if(d!==0){ e.preventDefault(); frameF = clamp(frameF + d, 0, total-1); scheduleDraw(); }
});

// Touch (vertical drag)
let tY=null;
window.addEventListener('touchstart', (e)=>{ if(e.touches.length===1) tY=e.touches[0].clientY; }, {passive:true});
window.addEventListener('touchmove', (e)=>{
  if(tY==null || e.touches.length!==1) return;
  const dy = tY - e.touches[0].clientY; // swipe up (negative) should advance → use -dy
  const step = (dy/100) * CONFIG.touchSensitivity * (total-1);
  frameF = clamp(frameF + step, 0, total-1);
  tY = e.touches[0].clientY;
  scheduleDraw();
}, {passive:true});
window.addEventListener('touchend', ()=> tY=null, {passive:true});

// Init
resize();
load(0).onload = ()=> drawFrame(0);
// Also kick off some early preloads
for(let k=1;k<=Math.min(4,total-1);k++) load(k);
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <link rel="icon" href="data:,">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Know-Hub — Products</title>
  <style>
    :root{
      --bg-light:#f7f7f8; --bg-dark:#e3e4e8;
      --panel:#ffffff; --panel-border:#dcdde1;
      --text:#222; --muted:#666;
      --accent:#ff6a00; --accent2:#2ea8ff;
    }
    html, body{ margin:0; background:linear-gradient(180deg,var(--bg-light),var(--bg-dark)); color:var(--text); font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif; overflow-x:hidden; }

    /* Navbar */
    nav{ position:fixed; inset:16px 16px auto 16px; height:52px; display:flex; align-items:center; justify-content:space-between; padding:0 16px; z-index:100; background:rgba(255,255,255,.75); border:1px solid var(--panel-border); border-radius:14px; backdrop-filter:blur(10px); box-shadow:0 4px 16px rgba(0,0,0,.06); }
    .brand{ font-weight:700; font-size:18px; background:linear-gradient(90deg,var(--accent),var(--accent2)); -webkit-background-clip:text; background-clip:text; color:transparent; }
    .nav-links{ display:flex; gap:12px; }
    .nav-btn{ padding:8px 14px; border-radius:10px; font-weight:500; cursor:pointer; background:#fff; border:1px solid var(--panel-border); color:var(--text); text-decoration:none; transition:background .15s ease, transform .15s ease, box-shadow .15s ease; }
    .nav-btn:hover{ background:#f0f0f0; transform:translateY(-1px); box-shadow:0 6px 14px rgba(0,0,0,.08); }
    .nav-btn.active{ border-color:transparent; background:linear-gradient(90deg,var(--accent),var(--accent2)); color:#fff; }

    /* Floating page title */
    header#title{ position:fixed; top:90px; left:50%; transform:translateX(-50%); z-index:90; font-size:clamp(24px,5vw,48px); font-weight:800; letter-spacing:.02em; background:rgba(255,255,255,.7); padding:10px 18px; border:1px solid var(--panel-border); border-radius:14px; box-shadow:0 4px 18px rgba(0,0,0,.08); }

    /* 1) HERO VIDEO SECTION */
    #hero{
      position:relative; height:100vh; overflow:hidden;
    }
    #hero video{
      position:absolute; inset:0; width:100%; height:100%;
      object-fit:cover; object-position:center;
      filter:contrast(1.02) saturate(1.02);
    }
    /* Optional overlay gradient for legibility */
    #hero::after{
      content:""; position:absolute; inset:0;
      background:linear-gradient(180deg, rgba(0,0,0,.25), rgba(0,0,0,.35) 60%, rgba(0,0,0,.45));
      pointer-events:none;
    }
    #heroContent{
      position:relative; z-index:2;
      height:100%; display:grid; place-items:center; text-align:center; color:#fff;
      padding:120px 20px 40px; /* keep clear of navbar */
    }
    .heroInner{
      max-width:1000px; margin:0 auto;
      backdrop-filter: blur(2px);
    }
    .heroTitle{
      font-weight:900; letter-spacing:.01em;
      font-size:clamp(36px,7vw,72px);
      margin:0 0 10px 0;
      background:linear-gradient(90deg,#fff, #d8ecff);
      -webkit-background-clip:text; -webkit-text-fill-color:transparent;
    }
    .heroSub{
      font-size:clamp(16px,2.2vw,20px); opacity:.95; margin:0 auto;
      color: #f1f5f9;
      max-width:840px;
    }
    .heroHint{
      position:absolute; bottom:24px; left:50%; transform:translateX(-50%);
      font:12px ui-monospace; color:#e2e8f0; opacity:.9;
      background:rgba(0,0,0,.35); padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.18);
    }

    /* 2) IMAGE-SEQUENCE SCRUB SECTION */
    #seqScrub{
      position:relative;
      height: 320vh;               /* length of scrub; increase for longer */
      padding-top: 140px;          /* clear fixed page title/nav */
      z-index:40;
      background:linear-gradient(180deg,var(--bg-light),var(--bg-dark));
    }
    #seqPin{
      position: sticky;
      top: 110px;                  /* sits under the fixed title */
      display:flex; justify-content:center;
    }
    #lottieCard{
      width: min(96vw, 1400px);    /* bigger hero card */
      background:var(--panel);
      border:1px solid var(--panel-border);
      border-radius:20px;
      box-shadow:0 14px 30px rgba(0,0,0,.12);
      padding:20px 20px 24px;
      text-align:center;
      opacity:0; transform:translateY(10px);
      transition:opacity .35s ease, transform .35s ease;
    }
    #lottieCard.show{ opacity:1; transform:translateY(0); }
    #lottieTitle{
      font-weight:800; font-size:20px; letter-spacing:.02em;
      margin:4px 0 14px 0;
      background:linear-gradient(90deg,var(--accent),var(--accent2));
      -webkit-background-clip:text; -webkit-text-fill-color:transparent;
    }
    #lottieHolder{
      width:100%;
      aspect-ratio:16/9;
      border-radius:14px;
      overflow:hidden;
      background:#f6f7fb;          /* subtle bg while canvas warms up */
      filter: drop-shadow(0 8px 24px rgba(0,0,0,.12));
    }

    /* 3) CONTENT AFTER SEQUENCE */
    .wrap{ max-width:1000px; margin:0 auto; padding:40px 20px 60px; position:relative; z-index:20; }
    section{ margin:120px 0; }
    .panel{ border-radius:16px; background:var(--panel); padding:28px; border:1px solid var(--panel-border); box-shadow:0 6px 18px rgba(0,0,0,.06); }
    .panel h2{ margin:0 0 8px 0; }
    .muted{ color:var(--muted); }

    /* Page loading overlay */
    #pageLoader{
      position:fixed; inset:0;
      display:grid; place-items:center;
      background:linear-gradient(180deg,var(--bg-light),var(--bg-dark));
      z-index:120;
      transition:opacity .35s ease, visibility .35s ease;
    }
    #pageLoader.hidden{ opacity:0; visibility:hidden; }
    .loaderCard{
      background:rgba(255,255,255,.92);
      border:1px solid var(--panel-border);
      border-radius:16px;
      padding:18px 22px;
      box-shadow:0 10px 24px rgba(0,0,0,.08);
      display:flex; align-items:center; gap:14px;
      font:14px ui-monospace; color:#333;
    }
    .spinner{ width:18px; height:18px; border-radius:50%;
      border:3px solid #ddd; border-top-color:var(--accent2);
      animation:spin .9s linear infinite; }
    @keyframes spin{ to{ transform:rotate(360deg); } }

    /* Status chip (optional) */
    #chip{ position:fixed; bottom:16px; left:16px; z-index:110; background:rgba(0,0,0,.75); color:#a7f3a7; font:12px ui-monospace; padding:6px 10px; border-radius:8px; }
  </style>
</head>
<body>
  <!-- Navbar -->
  <nav>
    <div class="brand">Know-Hub</div>
    <div class="nav-links">
      <a class="nav-btn" href="index.html">Home</a>
      <a class="nav-btn active" href="products.html">Products</a>
      <a class="nav-btn" href="#">About</a>
      <a class="nav-btn" href="#">Contact</a>
    </div>
  </nav>

  <!-- Floating page title -->
  <header id="title">Products</header>

<!-- 1) HERO with VIDEO background -->
<section id="hero" aria-label="Welcome">
  <video autoplay muted loop playsinline preload="auto" poster="videos/hero_poster.jpg">
    <source src="videos/yourvideo.webm" type="video/webm">
    <source src="videos/yourvideo.mp4" type="video/mp4">
  </video>
  <div id="heroContent">
    <div class="heroInner">
      <h1 class="heroTitle">Welcome to Know-Hub</h1>
      <p class="heroSub">A modern knowledge platform. Scroll to explore our animated product story.</p>
    </div>
    <div class="heroHint">Scroll ↓</div>
  </div>
</section>

  <!-- 2) IMAGE SEQUENCE scrub (pinned) -->
  <section id="seqScrub" aria-label="Product Animation">
    <div id="seqPin">
      <div id="lottieCard" aria-hidden="true">
        <div id="lottieTitle">Demo Animation</div>
        <div id="lottieHolder"></div>
      </div>
    </div>
  </section>

  <!-- Page loading overlay -->
  <div id="pageLoader">
    <div class="loaderCard">
      <div class="spinner" aria-hidden="true"></div>
      <div>Loading animation…</div>
    </div>
  </div>

  <!-- 3) Content after sequence -->
  <div class="wrap">
    <section class="panel">
      <h2>What you saw</h2>
      <p class="muted">We used a scroll-scrubbed image sequence. The card stayed centered and pinned while you scrolled the frames. After the last frame, the page continued.</p>
    </section>
    <section class="panel">
      <h2>How to wire assets</h2>
      <p class="muted">
        JSON at <code>/lottie/data.json</code>, images at <code>/lottie/images</code>
        as <code>seq_0_0.png</code>…<code>seq_0_229.png</code>. Video at <code>/media/hero.mp4</code> (plus optional <code>hero.webm</code> and <code>hero_poster.jpg</code>).
      </p>
    </section>
  </div>

  <div id="chip">Loading Lottie…</div>

  <!-- Lottie library -->
<script src="libs/lottie.min.js"></script>
<script>
  const chip        = document.getElementById('chip');
  const pageLoader  = document.getElementById('pageLoader');
  const lottieCard  = document.getElementById('lottieCard');
  const seqSection  = document.getElementById('seqScrub');
  const holder      = document.getElementById('lottieHolder');

  /* -------- load lottie -------- */
  function loadLottie(src){
    return new Promise((resolve, reject)=>{
      try{
        const anim = lottie.loadAnimation({
          container: holder,
          renderer: 'canvas',    // canvas is best for image sequences
          loop: false,
          autoplay: false,
          path: src,
          rendererSettings: {
            preserveAspectRatio: 'xMidYMid meet',
            progressiveLoad: true
          }
        });
        anim.addEventListener('data_ready', ()=> resolve(anim));
        anim.addEventListener('data_failed', ()=> reject(new Error('data_failed')));
        anim.addEventListener('error', (e)=> reject(e));
      }catch(e){ reject(e); }
    });
  }
  async function getSequenceFrameCount(src){
    try{
      const res = await fetch(src, { cache: 'no-store' });
      const json = await res.json();
      // count seq assets (e.g., seq_0_0 … seq_0_229) → 230 frames
      return (json.assets || []).filter(a => a.t === 'seq').length || null;
    }catch { return null; }
  }

  (async function init(){
    const jsonPath = 'lottie/data.json';

    // Boot + loader
    let anim;
    try{
      anim = await loadLottie(jsonPath);
      chip.textContent = 'Loading images…';
    }catch(e){
      chip.textContent = 'Failed to load lottie/data.json';
      console.error(e);
      return;
    }

    let revealed = false;
    const reveal = () => {
      if (revealed) return;
      revealed = true;
      pageLoader.classList.add('hidden');
      lottieCard.classList.add('show');
      chip.textContent = 'Scroll to scrub ↓';
    };
    anim.addEventListener('loaded_images', reveal);
    setTimeout(reveal, 2500); // safety reveal

    // Frame math
    let TOTAL_FRAMES = await getSequenceFrameCount(jsonPath);
    if (!TOTAL_FRAMES) {
      TOTAL_FRAMES = Math.max(1, Math.floor(anim.getDuration(true)));
    }
    // You said your last image is seq_0_229 → index 229
    const LAST_FRAME = TOTAL_FRAMES - 1; // should be 229
    let currentFrame = 0;
    let targetFrame  = 0;
    let progress01   = 0; // 0..1
    const EASE = 0.2;     // lower = smoother/slower

    function clamp01(v){ return Math.max(0, Math.min(1, v)); }
    function syncTarget(){ targetFrame = progress01 * LAST_FRAME; }

    // animation ticker
    function tick(){
      currentFrame += (targetFrame - currentFrame) * EASE;
      anim.goToAndStop(currentFrame, true);
      requestAnimationFrame(tick);
    }
    anim.goToAndStop(0, true);
    requestAnimationFrame(tick);

    // --- LOCK LOGIC ---
    // We *hard lock* the window scroll Y while scrubbing so the page won’t move.
    let locked     = false;
    let completed  = false;
    let lockY      = 0;       // where the page will be held while scrubbing
    let touchY     = null;

    function computeLockY(){
      // top of sequence section relative to the page
      lockY = window.scrollY + seqSection.getBoundingClientRect().top;
    }
    computeLockY();
    window.addEventListener('resize', computeLockY);

    function inSequenceViewport(){
      const top = seqSection.getBoundingClientRect().top;
      const bot = seqSection.getBoundingClientRect().bottom;
      // We engage lock once the section top hits viewport and until the section’s end.
      return (top <= 0) && (bot >= window.innerHeight);
    }

    function tryLockOnScroll(){
      if (completed) return; // once done, don't re-lock on normal scroll
      if (inSequenceViewport()){
        // Engage lock and hold scroll position
        if (!locked){
          locked = true;
          // snap to section top so it doesn’t “jiggle”
          computeLockY();
          window.scrollTo(0, lockY);
        }else{
          // keep it pinned at lockY while locked
          if (Math.abs(window.scrollY - lockY) > 1) window.scrollTo(0, lockY);
        }
      }else{
        locked = false;
      }
    }
    window.addEventListener('scroll', tryLockOnScroll, { passive:true });

    // Wheel scrubbing
    function onWheel(e){
      if (!locked) return;

      // If completed and user scrolls down, release page
      if (completed && progress01 >= 1 && e.deltaY > 0) {
        locked = false;
        // nudge page 1px so browser continues naturally
        window.scrollTo(0, lockY + 1);
        return;
      }

      e.preventDefault(); // <- stops page movement
      const SCALE = 0.0015; // tweak for scrub distance (lower = longer scrub)
      progress01 = clamp01(progress01 + e.deltaY * SCALE);
      syncTarget();

      // allow escape upward from the very start
      if (progress01 === 0 && e.deltaY < 0){
        locked = false;
        window.scrollTo(0, lockY - 1);
      }

      // when we hit the end, snap and pause on LAST_FRAME
      if (progress01 === 1 && !completed){
        completed = true;
        anim.goToAndStop(LAST_FRAME, true); // snap to 229
        chip.textContent = 'End of sequence';
        // remain locked until next wheel down, then release in the branch above
      }
    }

    // Touch scrubbing
    function onTouchStart(e){
      if (!locked) return;
      touchY = e.touches[0].clientY;
    }
    function onTouchMove(e){
      if (!locked) return;
      if (touchY == null) return;
      const y  = e.touches[0].clientY;
      const dy = touchY - y;
      e.preventDefault();
      const SCALE = 0.003; // touch needs a bit more
      progress01 = clamp01(progress01 + dy * SCALE);
      touchY = y;
      syncTarget();

      if (progress01 === 0 && dy < 0){
        locked = false;
        window.scrollTo(0, lockY - 1);
      }
      if (progress01 === 1 && !completed){
        completed = true;
        anim.goToAndStop(LAST_FRAME, true);
        chip.textContent = 'End of sequence';
      }
      // If completed and user swipes down, release
      if (completed && progress01 >= 1 && dy > 0){
        locked = false;
        window.scrollTo(0, lockY + 1);
      }
    }
    function onTouchEnd(){ touchY = null; }

    // Register (must be non-passive so we can preventDefault)
    window.addEventListener('wheel', onWheel, { passive:false });
    window.addEventListener('touchstart', onTouchStart, { passive:false });
    window.addEventListener('touchmove', onTouchMove, { passive:false });
    window.addEventListener('touchend', onTouchEnd);

    // If user jumps right into the section (PgDn etc.), lock immediately
    tryLockOnScroll();
  })();
</script>
</body>
</html>


